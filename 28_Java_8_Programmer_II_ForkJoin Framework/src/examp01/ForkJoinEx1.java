package examp01;

import java.util.Random;
import java.util.concurrent.ForkJoinPool;
import java.util.concurrent.RecursiveAction;




public class ForkJoinEx1 {

	public static void main(String[] args) {
	
//		Fork / Join 프레임 워크는 작은 작업으로 분할 할 수있는 큰 작업과 함께 작동하도록 설계되었습니다.
//		이것은 재귀를 통해 이루어지며, 기본 사례를 충족 할 때까지 작업을 계속 분할합니다.
//		Fork / Join 프레임 워크의 기본 클래스는 java.util.concurrent.ForkJoinPool이며 a subclass of ExecutorService.
//		ForkJoinPool주로 두 개의 생성자를 통해 인스턴스를 만듭니다 .
//		ForkJoinPool()
//		ForkJoinPool(int parallelism)
//		첫 번째 버전이 권장되는 방법입니다. 머신의 프로세서 수와 동일한 수의 스레드가있는 인스턴스를 생성합니다 (메소드 사용 Runtime.getRuntime().availableProcessors()).
		

//ExecutorService가 Runnable 또는 Callable로 표시되는 작업을 실행하는 것과 마찬가지로 Fork / Join 프레임 워크에서 작업은 일반적으로 다음 중 하나의 하위 클래스로 표시됩니다
//		RecursiveAction은 값을 반환하지 않는다는 점에서 Runnable과 동일합니다.
//		RecursiveTask <V>는 값을 반환한다는 점에서 Callable과 동일합니다.
//		둘 다 추상 클래스에서 확장됩니다 java.util.concurrent.ForkJoinTask.
//		그러나에서 ExecutorService사용 하는 작업자 스레드와 달리의 스레드 ForkJoinPool는 작업 도용 알고리즘을 사용합니다. 
//		즉, 스레드가 사용 가능할 때 여전히 다른 작업을 수행중인 다른 스레드의 보류중인 작업을 훔칩니다 .
		
//		이를 구현하기 위해 ForkJoinTask기반 클래스 의 세 가지 메서드가 프레임 워크에 중요합니다.
//
//		ForkJoinTask<V> fork()
//		V join()
//		// RecursiveAction을 확장하면
//		protected abstract void compute()
//		//RecursiveTask를 확장하면
//		protected abstract V compute()
//		위 코드의 각 스레드 ForkJoinPool에는 이러한 작업의 대기열이 있습니다.
//
//		처음에는 큰 작업이 있습니다. 이 작업은 기본 사례에 도달 할 때까지 (일반적으로) 두 개의 작은 작업으로 반복적으로 나뉩니다.
//
//		작업이 분할 될 때마다 fork()메서드를 호출하여 현재 스레드의 대기열에 첫 번째 하위 작업을 배치 한 다음 compute()두 번째 하위 작업 에서 메서드 를 호출 하여 결과를 재귀 적으로 계산합니다.
//
//		이런 식으로 첫 번째 하위 작업은 대기열에서 처리되거나 유휴 스레드에 의해 도난되어 프로세스를 반복합니다. 두 번째 하위 작업은 즉시 처리됩니다 (또한 프로세스 반복).
//
//		물론 모든 스레드를 바쁘게 유지하기 위해 작업을 충분한 시간으로 나누어야합니다 (이를 보장하기 위해 스레드 수보다 많은 작업으로 나누는 것이 좋습니다).
//
//		좋아, 이것을 검토 해보자. 첫 번째 하위 작업은 대기열에서 처리되기를 기다리고 있고 두 번째 하위 작업은 즉시 처리됩니다. 그렇다면 첫 번째 하위 작업의 결과는 언제 또는 어떻게 얻습니까?
//
//		첫 번째 하위 작업의 결과를 얻으려면 join()이 첫 번째 하위 작업 에서 메서드 를 호출합니다 .
//
//		join()결과가 반환 될 때까지 프로그램을 차단 하므로 이것이 마지막 단계 여야합니다 .
//
//		즉 , 메서드를 호출 하는 순서 가 중요 합니다.
//
//		join()전에 fork()를 호출하지 않으면 결과를 얻을 수 없습니다.
//		compute () 전에 join ()을 호출하면 프로그램이 마치 한 스레드에서 실행 된 것처럼 수행되고 시간을 낭비하게됩니다. 
//		두 번째 하위 작업이 값을 재귀 적으로 계산하는 동안 첫 번째 작업은 다른 스레드에서 도난 당할 수 있기 때문입니다. 
//		스레드를 처리합니다. 이렇게하면 join ()이 마지막으로 호출되면 결과가 준비되거나 결과를 얻기 위해 오래 기다릴 필요가 없습니다.
		
//		그러나 Fork / Join 프레임 워크가 모든 작업을위한 것은 아닙니다. 
//		반복적으로 해결할 수있는 모든 작업 (또는 구현할 수있는 알고리즘)에 사용할 수 있지만 더 작은 하위 작업으로 나눌 수 있고
//		독립적으로 계산할 수있는 작업에 가장 적합합니다 (순서는 중요하지 않음).
		
//		따라서 배열의 최소값을 찾는 간단한 예를 선택하겠습니다. 이 배열은 여러 하위 배열로 나눌 수 있으며 각각의 최소값을 찾을 수 있습니다. 그런 다음 해당 값 사이의 최소값을 찾을 수 있습니다.
//		이 포크 / 조인이 어떻게 작동하는지 확인하기 위해 먼저 RecursiveAction으로이 예제를 코딩 해 보겠습니다. 이 클래스는 결과를 반환하지 않으므로 부분 결과 만 인쇄 할 것임을 기억하십시오.
//		또 다른 한가지. 우리가 가질 수있는 가장 기본적인 시나리오 (기본 사례)는 두 값을 비교해야하는 경우입니다. 그러나 너무 작은 하위 작업은 잘 수행되지 않습니다.
//		따라서 포크 / 조인으로 작업 할 때 일반적으로 특정 크기 (단일 스레드로 처리 할 수있는)의 집합으로 요소를 분할하여 문제를 순차적으로 해결합니다.
		
//		이 예제에서는 스레드 당 5 개의 숫자를 처리해 보겠습니다. 
//		FindMinimumAction 클래스 보셈
		
	}

}
